<?xml version="1.0" ?>
<SmellBaseline>
  <Blacklist></Blacklist>
  <Whitelist>
    <ID>ComplexCondition:KeyInputFilter.kt$KeyInputFilter$(dIndex + 1 &lt; Key.Format.BASE64.length &amp;&amp; isAllowed(c) || dIndex + 1 == Key.Format.BASE64.length &amp;&amp; c == '=') &amp;&amp; dLength + (sIndex - start) &lt; Key.Format.BASE64.length</ID>
    <ID>ComplexMethod:Config.kt$Config.Companion$ @Throws(IOException::class, BadConfigException::class) fun parse(reader: BufferedReader): Config</ID>
    <ID>ComplexMethod:ErrorMessages.kt$ErrorMessages$private fun getBadConfigExceptionExplanation( resources: Resources, bce: BadConfigException ): String</ID>
    <ID>ComplexMethod:GoBackend.kt$GoBackend$@Throws(Exception::class) private fun setStateInternal(tunnel: Tunnel?, config: Config?, state: Tunnel.State?)</ID>
    <ID>ComplexMethod:InetNetwork.kt$InetNetwork.Companion$@Throws(ParseException::class) fun parse(network: String): InetNetwork</ID>
    <ID>ComplexMethod:InterfaceProxy.kt$InterfaceProxy$@Throws(BadConfigException::class) fun resolve(): Interface</ID>
    <ID>ComplexMethod:PeerProxy.kt$PeerProxy$@Throws(BadConfigException::class) fun resolve(): Peer</ID>
    <ID>ComplexMethod:QuickTileService.kt$QuickTileService$private fun updateTile()</ID>
    <ID>ComplexMethod:RootShell.kt$RootShell$@Synchronized @Throws(IOException::class, NoRootException::class) fun run(output: ArrayList&lt;String&gt;? = null, command: String): Int</ID>
    <ID>ComplexMethod:RootShell.kt$RootShell$@Synchronized @Throws(IOException::class, NoRootException::class) fun start()</ID>
    <ID>ComplexMethod:SettingsActivity.kt$SettingsActivity.SettingsFragment$override fun onCreatePreferences(savedInstanceState: Bundle?, key: String?)</ID>
    <ID>ComplexMethod:SharedLibraryLoader.kt$SharedLibraryLoader$fun extractNativeLibrary( context: Context, libName: String, useActualName: Boolean = false, skipDeletion: Boolean = false ): String?</ID>
    <ID>ComplexMethod:TaskerIntegrationReceiver.kt$TaskerIntegrationReceiver$override fun onReceive(context: Context?, intent: Intent?)</ID>
    <ID>ComplexMethod:ToolsInstaller.kt$ToolsInstaller$@Throws(NoRootException::class) fun areInstalled(): Int</ID>
    <ID>ComplexMethod:TunnelEditorFragment.kt$TunnelEditorFragment$override fun onOptionsItemSelected(item: MenuItem): Boolean</ID>
    <ID>ComplexMethod:TunnelListFragment.kt$TunnelListFragment$private fun importTunnel(uri: Uri?)</ID>
    <ID>ComplexMethod:TunnelListFragment.kt$TunnelListFragment$private fun onTunnelImportFinished(tunnels: List&lt;Tunnel&gt;, throwables: Collection&lt;Throwable&gt;)</ID>
    <ID>ConstructorParameterNaming:ConfigProxy.kt$ConfigProxy$`in`: Parcel</ID>
    <ID>ConstructorParameterNaming:InterfaceProxy.kt$InterfaceProxy$`in`: Parcel</ID>
    <ID>ConstructorParameterNaming:PeerProxy.kt$PeerProxy$`in`: Parcel</ID>
    <ID>EmptyFunctionBlock:AddTunnelsSheet.kt$AddTunnelsSheet${ }</ID>
    <ID>EmptyFunctionBlock:AddTunnelsSheet.kt$AddTunnelsSheet.&lt;no name provided&gt;.&lt;no name provided&gt;${ }</ID>
    <ID>ForbiddenComment:Tunnel.kt$Tunnel$// FIXME: Check age of statistics.</ID>
    <ID>FunctionParameterNaming:Config.kt$Config.Builder$`interface`: Interface</ID>
    <ID>LongMethod:GoBackend.kt$GoBackend$@Throws(Exception::class) private fun setStateInternal(tunnel: Tunnel?, config: Config?, state: Tunnel.State?)</ID>
    <ID>LongMethod:SettingsActivity.kt$SettingsActivity.SettingsFragment$override fun onCreatePreferences(savedInstanceState: Bundle?, key: String?)</ID>
    <ID>LongMethod:TunnelListFragment.kt$TunnelListFragment$private fun importTunnel(uri: Uri?)</ID>
    <ID>LongParameterList:BindingAdapters.kt$( view: RecyclerView, oldList: ObservableKeyedList&lt;K, E&gt;?, oldLayoutId: Int, oldRowConfigurationHandler: ObservableKeyedRecyclerViewAdapter.RowConfigurationHandler&lt;ViewDataBinding, E&gt;? = null, newList: ObservableKeyedList&lt;K, E&gt;?, newLayoutId: Int, newRowConfigurationHandler: ObservableKeyedRecyclerViewAdapter.RowConfigurationHandler&lt;ViewDataBinding, E&gt;? = null )</ID>
    <ID>NestedBlockDepth:RootShell.kt$RootShell$@Synchronized @Throws(IOException::class, NoRootException::class) fun start()</ID>
    <ID>NestedBlockDepth:SharedLibraryLoader.kt$SharedLibraryLoader$fun extractNativeLibrary( context: Context, libName: String, useActualName: Boolean = false, skipDeletion: Boolean = false ): String?</ID>
    <ID>NestedBlockDepth:SharedLibraryLoader.kt$SharedLibraryLoader$private fun getApkPath(context: Context): String</ID>
    <ID>SpreadOperator:TunnelListFragment.kt$TunnelListFragment$(*futureTunnels.toTypedArray())</ID>
    <ID>SpreadOperator:TunnelListFragment.kt$TunnelListFragment.ActionModeListener$(*futures)</ID>
    <ID>SpreadOperator:ZipExporter.kt$ZipExporter$(*futureConfigs.toTypedArray())</ID>
    <ID>TooGenericExceptionCaught:AsyncWorker.kt$AsyncWorker$t: Throwable</ID>
    <ID>TooGenericExceptionCaught:GoBackend.kt$GoBackend$e: Exception</ID>
    <ID>TooGenericExceptionCaught:QuickTileService.kt$QuickTileService$e: Exception</ID>
    <ID>TooGenericExceptionCaught:SharedLibraryLoader.kt$SharedLibraryLoader$e: Exception</ID>
    <ID>TooGenericExceptionCaught:TunnelEditorFragment.kt$TunnelEditorFragment$e: Exception</ID>
    <ID>TooGenericExceptionCaught:TunnelListFragment.kt$TunnelListFragment$e: Exception</ID>
    <ID>TooGenericExceptionCaught:TunnelListFragment.kt$TunnelListFragment$exception: Exception</ID>
    <ID>TooGenericExceptionCaught:TunnelManager.kt$TunnelManager$e: Exception</ID>
    <ID>TooGenericExceptionCaught:WgQuickBackend.kt$WgQuickBackend$e: Exception</ID>
    <ID>TooGenericExceptionCaught:ZipExporter.kt$ZipExporter$e: Exception</ID>
    <ID>TooGenericExceptionThrown:BackendFactory.kt$BackendFactory$throw Exception("Forcing userspace backend on user request.")</ID>
    <ID>TooGenericExceptionThrown:GoBackend.kt$GoBackend$throw Exception(context.getString(R.string.tun_create_error))</ID>
    <ID>TooGenericExceptionThrown:GoBackend.kt$GoBackend$throw Exception(context.getString(R.string.tunnel_on_error, currentTunnelHandle))</ID>
    <ID>TooGenericExceptionThrown:GoBackend.kt$GoBackend$throw Exception(context.getString(R.string.vpn_not_authorized_error))</ID>
    <ID>TooGenericExceptionThrown:GoBackend.kt$GoBackend$throw Exception(context.getString(R.string.vpn_start_error), e)</ID>
    <ID>TooGenericExceptionThrown:InetAddressUtils.kt$InetAddressUtils$throw RuntimeException(e)</ID>
    <ID>TooGenericExceptionThrown:SharedLibraryLoader.kt$SharedLibraryLoader$throw RuntimeException(e)</ID>
    <ID>TooGenericExceptionThrown:SharedLibraryLoader.kt$SharedLibraryLoader$throw RuntimeException(noAbiException)</ID>
    <ID>TooGenericExceptionThrown:WgQuickBackend.kt$WgQuickBackend$throw Exception(context.getString(R.string.module_version_error))</ID>
    <ID>TooGenericExceptionThrown:WgQuickBackend.kt$WgQuickBackend$throw Exception(context.getString(R.string.tunnel_config_error, result))</ID>
    <ID>TooManyFunctions:GoBackend.kt$GoBackend : Backend</ID>
    <ID>TooManyFunctions:Interface.kt$Interface$Builder : KoinComponent</ID>
    <ID>TooManyFunctions:KoinExtensions.kt$com.wireguard.android.di.ext.KoinExtensions.kt</ID>
    <ID>TooManyFunctions:Peer.kt$Peer$Builder</ID>
    <ID>TooManyFunctions:PeerProxy.kt$PeerProxy : BaseObservableParcelable</ID>
    <ID>TooManyFunctions:TunnelEditorFragment.kt$TunnelEditorFragment : BaseFragmentAppExclusionListener</ID>
    <ID>TooManyFunctions:TunnelListFragment.kt$TunnelListFragment : BaseFragment</ID>
    <ID>TooManyFunctions:TunnelManager.kt$TunnelManager : BaseObservableKoinComponent</ID>
    <ID>UnnecessaryLet:TunnelManager.kt$TunnelManager$let { it.forEach { future -&gt; if (t == null) future.complete(v) else future.completeExceptionally(t) } }</ID>
    <ID>UnnecessaryParentheses:ExceptionLoggers.kt$ExceptionLoggers.Companion$(throwable.cause ?: throwable)</ID>
    <ID>UnnecessaryParentheses:Interface.kt$Interface$(addresses == other.addresses &amp;&amp; dnsServers == other.dnsServers &amp;&amp; excludedApplications == other.excludedApplications &amp;&amp; keyPair == other.keyPair &amp;&amp; listenPort == other.listenPort &amp;&amp; mtu == other.mtu)</ID>
    <ID>UnnecessaryParentheses:Peer.kt$Peer$(allowedIps == other.allowedIps &amp;&amp; endpoint == other.endpoint &amp;&amp; persistentKeepalive == other.persistentKeepalive &amp;&amp; preSharedKey == other.preSharedKey &amp;&amp; publicKey == other.publicKey)</ID>
    <ID>UnnecessaryParentheses:TunnelDetailFragment.kt$TunnelDetailFragment$(!getPrefs().useDarkTheme &amp;&amp; !ctx.isSystemDarkThemeEnabled())</ID>
    <ID>UnnecessaryParentheses:TunnelEditorFragment.kt$TunnelEditorFragment$(!getPrefs().useDarkTheme &amp;&amp; !ctx.isSystemDarkThemeEnabled())</ID>
    <ID>UnusedPrivateMember:Config.kt$Config.Builder$`interface`: Interface</ID>
    <ID>UnusedPrivateMember:ConfigProxy.kt$ConfigProxy$`in`: Parcel</ID>
    <ID>UnusedPrivateMember:InterfaceProxy.kt$InterfaceProxy$`in`: Parcel</ID>
    <ID>UnusedPrivateMember:PeerProxy.kt$PeerProxy$`in`: Parcel</ID>
    <ID>UnusedPrivateMember:PeerProxy.kt$PeerProxy$val `interface` = it.`interface`</ID>
    <ID>UnusedPrivateMember:PeerProxy.kt$PeerProxy$val `interface` = owner.`interface`</ID>
    <ID>VariableNaming:Config.kt$Config$/** * Returns the interface section of the configuration. * * @return the interface configuration */ val `interface`: Interface</ID>
    <ID>VariableNaming:Config.kt$Config.Builder$// No default; must be provided before building. var `interface`: Interface? = null</ID>
    <ID>VariableNaming:ConfigProxy.kt$ConfigProxy$val `interface`: InterfaceProxy</ID>
    <ID>VariableNaming:PeerProxy.kt$PeerProxy$val `interface` = it.`interface`</ID>
    <ID>VariableNaming:PeerProxy.kt$PeerProxy$val `interface` = owner.`interface`</ID>
  </Whitelist>
</SmellBaseline>
